//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Windows.Forms;

namespace DigitalCircuit.Library
{
    /// <summary>
    /// Makes changes to the circuit and saves historical data in a list of steps.
    /// Is also able to undo and redo these steps.
    /// </summary>
    public class CircuitManager
    {
        /// <summary>
        /// The stack of undoable/redoable steps.
        /// </summary>
        private List<Step> steps;

        /// <summary>
        /// The first step that could be redone.
        /// </summary>
        private int indexNextRedo
        {
            get;
            set;
        }

        /// <summary>
        /// The previous step that could be undone
        /// </summary>
        private int indexNextUndo
        {
            get
            {
                return indexNextRedo - 1;
            }
        }
        /// <summary>
        /// The circuit that will be managed.
        /// </summary>
        public Circuit circuit
        {
            get;
            set;
        }

        public CircuitManager()
        {
            this.circuit = new Circuit();

            this.steps = new List<Step>();
            indexNextRedo = 0;
        }

        /// <summary>
        /// Add a step to the stack of undoable/redoable steps.
        /// </summary>
        /// <param name="step">The concerning step</param>
        private void addStep(Step step)
        {
            deleteUndoneSteps();
            steps.Add(step);
            indexNextRedo = steps.Count(); // Will be out of bounds
        }

        /// <summary>
        /// Adds an item to the circuit and adds the step to the stack.
        /// </summary>
        /// <param name="item"></param>
        /// <returns>True if successful, false if not.</returns>
        public bool addItem(Item item)
        {
            Step step = new Step();
            Action action = new Action(circuit, Action.ActionType.add, item);

            step.addAction(action);
            if (step.execute())
            {
                addStep(step);
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        ///  Deletes an item from the circuit and adds the step to the stack.
        /// </summary>
        /// <param name="item">The item that will be deleted</param>
        /// <returns> True if successful, false if not.</returns>
        public bool deleteItem(Item item)
        {
            Step step = new Step();

            List<Connection> associatedConnections = circuit.getAssociatedConnections(item);

            foreach (Connection associatedConnection in associatedConnections)
            {
                Action deleteAssociatedConnection = new Action(circuit, Action.ActionType.delete, associatedConnection);
                step.addAction(deleteAssociatedConnection);
            }

            Action action = new Action(circuit, Action.ActionType.delete, item);
            step.addAction(action);

            if (step.execute())
            {
                addStep(step);
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Adds a connection to the circuit and adds a step to the stack 
        /// </summary>
        /// <param name="connection">The connection that will be added</param>
        /// <returns>True if succesful, false if not</returns>
        public bool addConnection(Connection connection)
        {
            Step step = new Step();
            Action action = new Action(circuit, Action.ActionType.add, connection);

            step.addAction(action);
            if (step.execute())
            {
                addStep(step);
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Deletes a connection and add a step to the stack 
        /// </summary>
        /// <param name="connection">The connection that will be deleted</param>
        /// <returns>True if succesful, false if not</returns>
        public bool deleteConnection(Connection connection)
        {
            Step step = new Step();
            Action action = new Action(circuit, Action.ActionType.delete, connection);

            step.addAction(action);
            if (step.execute())
            {
                addStep(step);
                return true;
            }
            else
            {
                return false;
            }

        }

        /// <summary>
        /// Undoes the last step recorded in the stack.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public void undo()
        {
            Step stepToUndo = steps[indexNextUndo];
            stepToUndo.undo();
            indexNextRedo--;
        }
        /// <summary>
        /// Redoes the last undone step from the stack.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public bool redo()
        {
            try
            {
                Step stepToRedo = steps[indexNextRedo];
                if (stepToRedo.execute())
                {
                    indexNextRedo++;
                    return true;
                }
            }
            catch
            {
                return false;
            }
            return false;
        }
        /// <summary>
        /// Checks if any step has been undone before.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public bool redoPossible()
        {
            if (indexNextRedo < steps.Count())
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        /// <summary>
        /// Checks if there have been any steps done.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public bool undoPossible()
        {
            if (indexNextUndo >= 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Removes all the undone steps from the stack.
        /// </summary>
        private void deleteUndoneSteps()
        {
            int totalSteps = steps.Count();
            int stepsToRemove = totalSteps - indexNextRedo;
            steps.RemoveRange(indexNextRedo, stepsToRemove);
        }

        /// <summary>
        /// Changes source from 0 to 1 and vice versa.
        /// </summary>
        /// <param name="source"></param>
        public void toggle(IToggleable toggable)
        {
            Step step = new Step();
            Action action = new Action(circuit, Action.ActionType.toggle, toggable);

            step.addAction(action);
            step.execute();
            addStep(step);
        }

        /// <summary>
        /// Load a circuit from a filestream
        /// </summary>
        /// <param name="fileStream">Filestream with saved circuit</param>
        public void LoadFromFile(FileStream fileStream)
        {
            BinaryFormatter bFormatter = new BinaryFormatter();
            this.circuit = (Circuit)bFormatter.Deserialize(fileStream);
            this.circuit.Initialize();
        }

        /// <summary>
        /// Delete connections that are associated with a port
        /// </summary>
        /// <param name="port">The concerning port</param>
        public void deleteConnectionsForPort(Port port)
        {
            List<Connection> connectionsToDelete = circuit.getAssociatedConnections(port);
            foreach (Connection connection in connectionsToDelete)
            {
                deleteConnection(connection);
            }
        }
    }
}