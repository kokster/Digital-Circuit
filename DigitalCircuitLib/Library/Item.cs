//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.Serialization;

namespace DigitalCircuit.Library
{
    /// <summary>
    /// An abstract thing that can be added to a circuit, except connections. 
    /// It has a location on the circuit and has a bounding box.
    /// </summary>
    /// 
[Serializable()]
    public abstract class Item : ISerializable
    {
        /// <summary>
        /// Event that will be fired when the output of the item has been changed
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="newValue"></param>
        public delegate void OutputChangedHandler(object sender, bool? newValue);
        public virtual event OutputChangedHandler OutputChanged;

        /// <summary>
        /// The exact location specified by absolute coordinates.
        /// </summary>
        private Point location;
        public virtual Point Location
        {
            get
            {
                return this.location;
            }
            set
            {
                this.location = value;
            }
        }
        
        /// <summary>
        /// The width of the item
        /// </summary>
        public int Width = 100;

        /// <summary>
        /// The height of the item
        /// </summary>
        public int Height = 100;

        /// <summary>
        /// The boundingBox is used to check whether two items are intersecting, or whether an item is clicked.
        /// </summary>
        public Rectangle BoundingBox
        {
            get
            {
                return new Rectangle(location.X, location.Y, Width, Height);
            }
        }

        /// <summary>
        /// Array of inputs
        /// </summary>
        private Port[] inputs;
        public Port[] Inputs
        {
            get
            {
                return this.inputs;
            }
            set
            {
                this.inputs = value;
            }
        }

        /// <summary>
        /// Array of outputs
        /// </summary>
        private Port[] outputs;
        public Port[] Outputs
        {
            get
            {
                return this.outputs;
            }
            set
            {
                this.outputs = value;
            }
        }

        /// <summary>
        /// Calculates the output based on the input.
        /// </summary>
        /// <returns></returns>
        public abstract bool? getOutput();
        
        /// <summary>
        /// The latest calculated output of the item
        /// </summary>
        private bool? output;

        public Item(int inputs, int outputs)
        {
            Inputs = new Port[inputs];
            for (int i = 0; i < inputs; i++)
            {
                Inputs[i] = new Port(this, true);
                Inputs[i].PoweredChanged += ItemInput_PoweredChanged;
            }

            Outputs = new Port[outputs];
            for (int i = 0; i < outputs; i++)
            {
                Outputs[i] = new Port(this, false);
            }

            this.output = getOutput();
        }

        public Item(SerializationInfo info, StreamingContext context)
        {
            this.location = (Point)info.GetValue("Location", typeof(Point));
            this.inputs = (Port[])info.GetValue("Inputs", typeof(Port[]));
            this.outputs = (Port[])info.GetValue("Outputs", typeof(Port[]));
            this.output = (bool?)info.GetValue("Output", typeof(bool?));
        }
        
        /// <summary>
        /// Reinitilize an item after deserialization
        /// </summary>
        public bool initialized = false;
        public void Initialize()
        {
            for (int i = 0; i < inputs.Count(); i++)
            {
                this.Inputs[i].Initialize(this);
                Inputs[i].PoweredChanged += ItemInput_PoweredChanged;
            }


            for (int i = 0; i < outputs.Count(); i++)
            {
                this.outputs[i].Initialize(this);
            }

            initialized = true;
        }
        
        /// <summary>
        /// Get the ports of the item
        /// </summary>
        /// <returns>The list of ports</returns>
        public List<Port> getPorts()
        {
            List<Port> ports = new List<Port>();
            ports.AddRange(inputs);
            ports.AddRange(outputs);

            return ports;
        }

        /// <summary>
        /// Powered changed handler that will fire when one of the inputs has been changed.
        /// A new calculation for the output will made and will fire a PoweredChanged event
        /// if the output has been changed
        /// </summary>
        /// <param name="sender"></param>
        private void ItemInput_PoweredChanged(object sender)
        {
            bool? newOutput = getOutput();
            if (output != newOutput)
            {
                output = newOutput;
                try
                {
                    OutputChanged(this, newOutput);
                }
                catch { }
            }
        }
        
        /// <summary>
        /// Checks if there is at least on port that isn't used
        /// </summary>
        /// <returns></returns>
        public bool unusedPortExists()
        {
            foreach (Port input in Inputs)
            {
                if (input.Powered == null)
                {
                    return true;
                }
            }

            return false;
        }

        public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("Location", this.location);
            info.AddValue("Inputs", this.inputs);
            info.AddValue("Outputs", this.outputs);
            info.AddValue("Output", this.output);
        }
    }
}