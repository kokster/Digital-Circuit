//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace DigitalCircuit.Library
{
    /// <summary>
    /// Makes changes to the circuit and saves historical data in a list of steps.
    /// Is also able to undo and redo these steps.
    /// </summary>
    public class CircuitManager
    {
        /// <summary>
        /// The stack of undoable/redoable steps.
        /// </summary>
        private List<Step> steps;

        /// <summary>
        /// The first step that could be redone.
        /// </summary>
        private int indexNextRedo
        {
            get;
            set;
        }

        private int indexNextUndo
        {
            get
            {
                return indexNextRedo - 1;
            }
        }
        /// <summary>
        /// The circuit that will be managed.
        /// </summary>
        private Circuit circuit
        {
            get;
            set;
        }

        public CircuitManager(Circuit circuit)
        {
            this.circuit = circuit;
            this.steps = new List<Step>();
            indexNextRedo = 0;
        }

        private void addStep(Step step)
        {
            deleteUndoneSteps();
            steps.Add(step);
            indexNextRedo = steps.Count(); // Will be out of bounds
        }

        /// <summary>
        /// Adds an item to the circuit and adds the step to the stack.
        /// </summary>
        /// <param name="item"></param>
        /// <returns>True if successful, false if not.</returns>
        public bool addItem(Item item)
        {
            Step step = new Step();
            Action action = new Action(circuit, Action.ActionType.add, item);
            
            step.addAction(action);
            if (step.execute())
            {
                addStep(step);
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        ///  Deletes an item from the circuit and adds the step to the stack.
        /// </summary>
        /// <param name="item"></param>
        /// <returns> True if successful, false if not.</returns>
        public bool deleteItem(Item item)
        {
            throw new System.NotImplementedException();
        }
        /// <summary>
        /// Undoes the last step recorded in the stack.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public void undo()
        {
            Step stepToUndo = steps[indexNextUndo];
            stepToUndo.undo();
            indexNextRedo--;
        }
        /// <summary>
        /// Redoes the last undone step from the stack.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public bool redo()
        {
            try
            {
                Step stepToRedo = steps[indexNextRedo];
                if (stepToRedo.execute())
                {
                    indexNextRedo++;
                    return true;
                }
            }
            catch
            {
                return false;
            }
            return false;
        }
        /// <summary>
        /// Checks if any step has been undone before.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public bool redoPossible()
        {
            if (indexNextRedo < steps.Count())
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        /// <summary>
        /// Checks if there have been any steps done.
        /// </summary>
        /// <returns>True if successful, false if not.</returns>
        public bool undoPossible()
        {
            if (indexNextUndo >= 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Removes all the undone steps from the stack.
        /// </summary>
        private void deleteUndoneSteps()
        {
            int totalSteps = steps.Count();
            int stepsToRemove = totalSteps - indexNextRedo;
            steps.RemoveRange(indexNextRedo, stepsToRemove);
        }

        /// <summary>
        /// Changes source from 0 to 1 and vice versa.
        /// </summary>
        /// <param name="source"></param>
        public void toggle(IToggleable toggable)
        {
            throw new System.NotImplementedException();
        }

    }
}